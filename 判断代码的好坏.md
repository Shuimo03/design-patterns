### 评价代码

判断一个人写的代码好坏，不能简单的说这个代码好或者烂，也不是说一堆专业名词来评价，而是指出为什么不好或者为什么好。如果时间和能力允许，可以对代码进行重构。

代码质量的评价有很强的主观性。

### 最常用的指标

+ 可维护性
+ 可读性
+ 可扩展性
+ 灵活性
+ 简洁性(简单，复杂)
+ 可复用性
+ 可测试性

### 可维护性

可维护性是指在不破坏原有代码设计，不引入新的bug情况下，能够快速的修复或者添加代码，**如果代码分层清晰，模块化好，高内聚低耦合，遵守基于接口而非实现代码的设计原则就会让代码变得容易维护。**

比较经典的MVC分层思想。

### 可读性

代码的可读性前提是有没有遵守团队的编码规范，如果团队没有编码规范就应该遵守有名的开源社区规范。

代码的可读性是指是否符合编码规范，命名能不能让人直接看懂，注释是否详细，函数长度，模块的划分等等。

其实如果可维护性做好了，那代码的可读性也就上来了。不过每个人的代码水平不一样，所以至少可以通过函数名晓得这个函数是做什么的，如果不能做到这一点的话，说明可读性就不行了。

### 可扩展性

代码的可扩展性，在不修改或者少量修改原有代码的情况下，通过扩展的方法添加新的功能代码，比如最近我遇到的一个场景，根据不同厂商提供的SDK来实现创建主机，让主机关机等等，原来的代码是这样的：

```
switch Corp{
case A:
	创建/其他操作A
case B:
	创建/其他操作B
}
```

这样的代码算是满足了可读性，因为很方便的通过命名来知道这个switch是做什么的，但是对于可扩展性来说就比较麻烦，因为如果有n个厂商进来的话，那就需要case n个，那提供这一层的代码就会变变得很多。

如果使用工厂模式的话，就会减少这些代码。

### 灵活性

还是之前的例子，当有一个新的厂商需要添加进来的时候，我们只需要在扩展点上添加新的代码就可以了，这个时候代码就具有灵活性了。

如果一段代码容易扩展和服用或者易用，那这段代码就写的比较灵活。

### 简洁性

### 可复用性

### 可测试性

## 扩展

+ 单一职责
+ DRY
+ 基于接口而非实现
+ 里氏替换
+ 
